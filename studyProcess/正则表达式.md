#正则表达式
##正则表达式简介
  正则表达式也成为模式表达式，自身具有一套非常完整，可以编写模式的语法体系，提供了一种灵活且直观的字符串处理方法。正则表达式通过构建具有特定规则的模式，与输入的字符串信息比较，在特定的函数中使用从用实现字符串的匹配，查找，替换及分割等操作。
- **选择PHP正则表达式的处理函数**
  在PHP中支持两套正则表达式的处理函数。一套由PCRE库提供的，与Perl语言兼容的正则表达式函数。使用以"preg_"为前缀命名的函数，而且表达式都应当被包含在定界符中，如斜线`(\)`。另一套是由POSIX扩展语法的正则表达式函数，使用以"ereg_"为前缀命名的函数。两套函数库的功能相似，执行效率稍有不同。一般而言，实现相同的功能，使用第一种PCRE库提供的正则表达式效率略占优势。
  preg_match()                    进行正则表达式匹配
  preg_match_all()            进行全局正则表达式匹配
  preg_replace()             执行正则表达式的搜索与替换
  preg_split()               用正则表达式分割字符串
  preg_grep()                返回与模式匹配的数组单元
  preg_replace_callback()    用回掉函数执行正则表达式的搜索与替换
##正则表达式的语法规则
  正则表达式作为一个匹配的模板，是由原子(普通字符，例如a到z),有特殊功能的字符(称为元字符，例如*,+和?等)，以及模式修正符三个部分组成的文字模式。一个最简单的正则表达模式中，至少也要包含一个原子，如`\a\`。而且在于Perl兼容的正则表达式函数中使用模式时，一定要给模式加上定界符，即将模式包含在反斜线`/`之间。
   - **定界符**
     在程序语言中，使用与Perl兼容的正则表达式，通常都需要将模式表达式放入定界符之间。作为定界符也不仅仅局限于使用`"\"`。除了字母，数字和反斜线以外的任何字符都可以作为定界符号。例如`# ! {}  | `等都是可以的。通常习惯于两个斜线
   - **原子**
     原子是正则表达式的最基本的组成单位，而且在每个模式中最少要包含一个原子。原子是由所有的那些未显示指定为元字符的打印和非打印字符组成。
      - **普通字符原子**
        是编写正则表达式是最常见的原子了，包括所有的大写和小写字母字符，所有数字等。
      - **一些特殊字符和元字符作为原子**
        任何一个符号都可以作为原子使用，但是如果这个符号在正则表达式中有特殊意义，我们就必须只用转义字符\取消它的特殊意义，将其变为一个普通的原子。
         ```
         '/\.'                 用来匹配字符串中是否有英文的.出现
         '\\<br\/\>\'          用来匹配字符串中是否有HTML的<br/>标记字符串出现
         ``` 
      - **一些非打印字符作为原子**
        所谓的非打印字符，是一些在字符串中的格式控制符号，例如空格，回车及制表符号等。
        |原子字符|含义描述|
        | ----- | ----- |
        |\cx|匹配由x指明的控制字符。例如\cM匹配一个Control-M或回车键。x的值必须为A~Z或a~z之一。否则将c视为一个原义的'c'字符|
        |\f|匹配一个换页符。等价于\x0c和\cL|
        |\n|匹配一个换行符。等价于\x0a和\xJ|
        |\r|匹配一个回车符。等价于\x0d和\cM|
        |\t|匹配一个制表符。等价于\x09和cL|
        |\v|匹配一个垂直制表符。等价于\x0b和cK|
      - **使用"通用字符类型"作为原子**
        一个于原子匹配一类字符
        |原子字符|含义描述|
        | ----- | ----- |
        |\d|匹配任意一个十进制数字，等价于[0-9]|
        |\D|匹配任意一个除十进制数字以外的字符，等价于[^0-9]|
        |\s|匹配任意一个空白字符，等价于[\f\n\r\t\v]|
        |\S|匹配一个除空白字符意外任意一个字符，等价于[^\f\n\r\t\v]|
        |\w|匹配任意一个数字，字母或下划线，等价于[0-9a-zA-Z]|
        |\W|同上|
      - **自定义原子表([])作为原子**
        因为某一类的原子实在太多了，系统不能全部都给提供出来，例如数字中的奇数(1,3,5,7,9)，字母中的元音字母(a,e,i,o,u)等。所以就需要我们可以自己定义出特定的"类原子"，使用原子表"[]"就可以定义一组彼此地位平等的原子，且从原子表中仅选择一个原子进行匹配。
        ```
        '/[aps]sp/'    --可以匹配asp,psp,jsp三种，从原子表中仅选择一个作为原子。
        ```
    - **元字符**
      利用Perl正则表达式还可以做另一件事，就是使用各种元字符来搜索匹配。所谓的元字符，就是用于构建正则表达式的具有特殊含义的字符，例如`* + ?`等。元字符不能单独出现，他必须用来修饰原子的。如果要在正则表达式中包含元字符本身，使其失去特殊的含义，则必须在前面加上`\`进行转义。
      |元字符|含义描述|
      | ------ | ------ |
      |*|匹配0次，1次或多次以前的原子|
      |+|匹配1次或多次以前的原子|
      |？|匹配0次或1次以前的原子|
      |.|匹配除了换行符外的任意字符|
      | \| |匹配两个或多个分支选择|
      |{n}|表示其前面的原子恰好出现n次|
      |{n,}|表示其前面的原子出现不少于n次|
      |{n,m}|表示其前面的原子至少出现n次，最多出现m次|
      |^或\A|匹配字符的输入位置(或在多行模式下行的开头，即紧随一换行符之后)|
      |$或\Z|匹配字符串的结束位置(或在多行模式下行的结尾，即紧随一换行符之前)|
      |\b|匹配单词边界|
      |\B|匹配出单词边界以外的部分|
      |[]|匹配方括号中指定的任意一个原子|
      |[^]|匹配方括号中的原子以外的任意一个原子|
      |()|匹配其整体为一个原子，即模式单元。可以理解为由多个单原子组成的大原子|
      - **限定符**
        限定符用来指定正则表达式的一个给定原子必须要出现多少次才满足匹配。
        ```
        '/a\s*b/'   --可以匹配a和b之间没有空白，有一个或多个空白的情况
        ```
      - **边界限制**
        用来限定字符串或单词的边界范围以获取更准确的匹配结果。
        ```
        $str = 'this is a test'
        '/^this/'   匹配此字符串是否以"this"开头
        '/this$/'   匹配此字符串是否以"this"结尾

        ```
      - **句号(.)**
        ` /a.b/ 匹配a和b之间有一个任意的字符的字符串`
      - **模式选择符(|)**
        `/php|javascript|html|css/ 从中任意匹配一组`
      - **模式单元**
        使用()。
        `/(very)*good/  --可以匹配good,very good,very very ...good`
      - **后向引用**
        使用元字符`“()”`标记的开始和结束多个原子，不仅是一个独立的单元，也是一个子表达式。这样对于一个正则表达式模式或部分模式两边添加圆括号导致相关匹配存储到一个临时缓冲区，可以被获取供以后使用。所捕获的每个子匹配都按照在正则表达式模式中从左至右所遇到的内容存储。存储子匹配的缓冲区编号从1开始，连续编号直至99个子表达式。每个缓冲区可以使用\n'访问，其中n为一个标识特定缓冲区的以为或两位十进制数。如"\1",'\2'等形式引用。表达式中需要加一个`\`进行转义。
        ```
        '/^\d{4}\W\d{2}\W\d{2}$/'
        '/^\d{4}(\W)\d{2}\\1\d{2}$/'
        ```  
        当需要使用模式单元而又不想存储匹配结果时，可以使用非捕获元字符"?:","?=","?!"来忽略对相关匹配的保存。
      - **模式匹配的优先级**
        |顺序|元字符|描述|
        | ----- | ----- | ----- |
        |1| \| 转意符号|
        |2|() `(?:)` (?=)   [] |模式单元和原子表|
        |3| * + ? {n} {n,} {n,m}|重复匹配|
        |4|^ $ \b \B \A \Z| 边界限制|
        |5| \| |模式选择| 
   - **模式修正符**
     模式修正符号是在正则表达式定界符之外使用(最后一个斜线"/"之后)。
     |模式修正符号|功能描述|
     | ----- | ------ |
     |i|不区分大小写|
     |m|将字符串视为多行化。默认的正则开始"^"和结束"$"将字符串作为单一的一行字符(甚至其中包含有换行符也是如此)。如果在修饰符中加上"m"，那么开始和结束将会指定字符串的每一行，每一行的开始就是"^"，结束就是"$"|
     |s|若设定了此修订符，在模式中的圆点元字符"."匹配所有的字符，包括换行符。即将字符串视为单行，换行符作为不同字符看待。|
     |x|模式中空白不计，除非它已经被转义|
     |e|只用在preg_replace()函数中，在替换字符串中对逆向引用作正常的替换，将其作为php代码求值，并用其结果来替换所搜索的字符串|
     |U|本修正符反转了匹配数量的值使其不是默认的重复，而变成在后面跟上"?"才变得重复。这和Perl不兼容。也可以通过在模式中设定(U)修正符或者在数量符之后跟一个问号来用此选项|
     |D|模式中的美元元字符仅匹配目标字符串的结尾。没有此选项时，如果最后一个字符是换行符的话，美元符号也会匹配匹配此字符之前。如果设定了m修正符则忽略此选项|
##与Perl兼容的正则表达式函数
  - **字符串的查找与匹配**
    - **函数preg_match()**
      通常用于表单验证，可以按指定的正则表达式模式，对字符串进行搜索匹配和匹配一次。
      该函数有两个必选参数，第一个参数pattern需要提供用户的正则表达式，第二个参数需要一个字符串。该函数的作用就是在第二个字符串参数中，搜索与第一个参数给出的正则表达式匹配的匹配结果。
      ```
      $rules = '/^(http?|https?|ftps?):\/\/(www)\.([^\.\/]+)\.(com|net|org)$/i';
      $url = "http://www.baidu.com";

      if (preg_match($rules  , $url ,$matches)){
           print_r($matches[1]);
      }else{
           echo  0;
      }
      ```
    - **函数preg_match_all()**
      该函数与preg_match()函数相似，不同的是函数preg_match()在第一次匹配之后就会停止搜索。而函数preg_match_all()则会一直搜索到指定字符串的结尾，可以获取到所有匹配到的结果。
      该函数将把所有可能的匹配结果放入第三个参数的数组中，并返回整个模式匹配的次数，如果出错则返回flase。如果使用了第四个参数，会根据他指定的顺序将每次出现的匹配结果保存到第三个参数的数组中。第四个flags有以下两个预定值。
      **PREG_PATTERN_ORDER:** 他是preg_match_all()函数的默认值，对结果排序使`$matches[0]`为全部模式匹配的数组，`$matches[1]`为第一个括号中的子模式所匹配得字符串组成的数组，一次类推。
      **PREG_SET_ORDER:** 对结果排序使`$matches[0]`为第一组匹配项的数组，`$matches[1]`为第二组匹配项的数组，以此类推。
    - **函数preg_grep**
      该函数与前两个函数不同的是匹配数组中的元素，返回与正则表达式匹配的数组单。该函数返回一个数组，其中包括了第二个参数input数组中与给定的第一个参数pattern模式相匹配的单元。只进行一次匹配。
      ```
      $arr = array("Linux RedHat9.0" , "Apache2.2.9","MySQL5.0.51" ,"PHP7.2" );

      $back = preg_grep("/^[a-zA-Z]+(\d\.)/",$arr);

      print_r($back);


      Array
      (
         [1] => Apache2.2.9
         [2] => MySQL5.0.51
         [3] => PHP7.2
      )
      ```
    - **字符串处理函数**
      如果只是查找一个子字符串中是否包含某个子字符串，建议使用`strstr()或strpos()函数`，如果只是简单的从一个字符串中取出一段子字符串，建议使用`substr()函数`。虽然不能完成复杂操作，但执行效率高于正则表达式。
      ```
      echo  strstr("this is a test" , "test");

      echo  strstr("this is a test" , 115);

      test
      s is a test
      ```
    - **字符串的替换**
      对于一些比较复杂的字符串替换操作，可以通过正则表达式的替换函数`preg_replace()`来完成。而对于简单的替换操作，建议使用`str_replace()`函数。
      - **preg_replace()**
        该函数可执行正则表达式的搜索和替换，是一个强大的字符串替换处理函数。
        ```
        $pattern = "/<[\/\!]*?[^<>]*?>/is";
        $text = '这是一个文本内容<b>粗体</b>和<u>带下划线</u>';
        echo preg_replace($pattern , " ",$text);


        这是一个文本内容 粗体 和 带下划线 


        $pattern = "/(\d{2})\/(\d{2})\/(\d{4})/";
        $text = "今年国庆的日期为10/01/2019到10/07/2019";
        echo  preg_replace($pattern ,"\${3}-\${1}-\${2}" , $text);


        今年国庆的日期为2019-10-01到2019-10-07
        ```
        在使用`preg_replace()`函数时，有一个专门为他提供的模式修正符"e"。也只有此函数使用此修正符。如果设定了修正符，函数在替换字符串的对逆向引用做正常的替换，将其作为php代码求值，并用其结果替换所搜索的字符串。要确保第二个参数是合法的php代码字符串。**新版php中已经不提供支持e**
        新版中可以使用`preg_replace_callback()`来代替做相应的运算。此函数的第二个函数为一个回调函数，做相应的运算处理。
        ```
         $pattern = "/(<[\/]?)(\w+)([^<>]*>)/";
         function  back($match){
               return  "$match[1]$match[2]$match[3]";
         }

         $txt = "这是一个文本<b>粗体</b>和<u>带有下划线</u>还有<p style='display: block ; background: aliceblue'>这是一个p标签</p>";
         echo  preg_replace_callback($pattern , "back" , $txt);

          
          这是一个文本<b>粗体</b>和<u>带有下划线</u>还有<p style='display: block ; background: aliceblue'>这是一个p标签</p>


          function backA($match){
               return "$match[1]".strtoupper($match[2])."$match[3]";
          }

          echo  preg_replace_callback($pattern , "backA" , $txt);

          这是一个文本<B>粗体</B>和<U>带有下划线</U>还有<P style='display: block ; background: aliceblue'>这是一个p标签</P>
        ```
  - **字符串的分割和连接**
    - **函数preg_split()**
      该函数使用了Perl兼容的正则表达式语法，可以按正则表达式的方法分割字符串，因此可以使用更广泛的分隔符。本函数返回一个字符串数组，数组元素包含通过第二个参数subject中的字符串，经第一个参数的正则表达式，作为匹配边界所分割的字符串。如果指定了第三个可选参数limit，则最多返回limit个子串，而其中最后一个元素包含了subject中剩余的所有部分。如果limit是-1，则意味着没有限制。还可以用来继续指定第四个可选参数flags,其中flags可以是下列标记的任意组合：
      PREG_SPLIT_NO_EMPTY:  此函数返回非空的成分。
      PREG_SPLIT_DELIM_CAPTURE:定界符模式中的括号表达式也会被捕获并返回。
      PREG_SPLIT_OFFSET_CAPTURE:对每个出现的匹配结果也同时返回相应字符串的偏移量。注意这改变了返回数组的值，使其中的每个单元也是一个数组，其中第一项为匹配字符串，第二项为其在subject中的偏移量。
      ```
      $str = 'this is a book';
      $change =  preg_split("/ /",$str);
      print_r($change);

      Array
      (
        [0] => this
        [1] => is
        [2] => a
        [3] => book
      )


      $change =  preg_split("//",$str);
      print_r($change);

      Array
      (
        [0] => 
        [1] => t
        [2] => h
        [3] => i
        [4] => s
        [5] =>  
        [6] => i
        [7] => s
        [8] =>  
        [9] => a
        [10] =>  
        [11] => b
        [12] => o
        [13] => o
        [14] => k
        [15] => 
        )

        $str = 'this is a book';
        $change =  preg_split("/ /",$str , -1 ,4);//在新版php中，第四个参数只能为int类型的参数，而最先的参数都有与之相对应的数字
        print_r($change);

        Array
        (
            [0] => Array
            (
               [0] => this
               [1] => 0
            )

        [1] => Array
           (
              [0] => is
              [1] => 5
           )

        [2] => Array
           (
              [0] => a
              [1] => 8
           )

       [3] => Array
           (
             [0] => book
             [1] => 10
           )

       )

      ```
    - **函数explode()**
      如果仅用某个特定的字符串进行分割，建议使用此函数。他不用去调用正则表达式引擎，因此速度最快。
      该函数有三个参数，第一个参数提供一个分割字符或字符串，第二个参数是被分割的字符串第三个参数可选参数limit，指定最多将字符串分割为多少个子串。该函数返回一个有被分割的子字符串组成的数组。如果第一个参数为空(""),此函数则返回FALSE。如果找不到，则返回包含string单个元素的数组。
      ```
      $str = 'Linux Apache MySQL PHP';
      $back = explode(" " , $str);
      print_r($back);

      Array
      (
         [0] => Linux
         [1] => Apache
         [2] => MySQL
         [3] => PHP
      )
      ```
    - **函数implode()**
      与分割字符串的函数相反，此函数把数组中的所有元素组合为一个字符串。函数join为改函数的别名。
      ```
      echo implode(".",$back);
      Linux.Apache.MySQL.PHP

      echo join(".",$back);
      Linux.Apache.MySQL.PHP
      ```


**相关链接**
 [一个正则表达式引发的血案，让线上CPU100%异常！](https://juejin.im/post/5b287ea6f265da596d04a324)

      















